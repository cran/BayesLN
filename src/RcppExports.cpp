// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/BayesLN.h"
#include <RcppEigen.h>
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// rmn_mu_S2
void rmn_mu_S2(Eigen::VectorXd& rnd_vec, const int p, const Eigen::VectorXd mu, const Eigen::MatrixXd S);
static SEXP _BayesLN_rmn_mu_S2_try(SEXP rnd_vecSEXP, SEXP pSEXP, SEXP muSEXP, SEXP SSEXP) {
BEGIN_RCPP
    Rcpp::traits::input_parameter< Eigen::VectorXd& >::type rnd_vec(rnd_vecSEXP);
    Rcpp::traits::input_parameter< const int >::type p(pSEXP);
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type mu(muSEXP);
    Rcpp::traits::input_parameter< const Eigen::MatrixXd >::type S(SSEXP);
    rmn_mu_S2(rnd_vec, p, mu, S);
    return R_NilValue;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesLN_rmn_mu_S2(SEXP rnd_vecSEXP, SEXP pSEXP, SEXP muSEXP, SEXP SSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesLN_rmn_mu_S2_try(rnd_vecSEXP, pSEXP, muSEXP, SSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// MCMC_alg
Rcpp::List MCMC_alg(const Eigen::VectorXd y, const Eigen::MatrixXd X, const List Z_list, const List K_gamma_list, const Eigen::MatrixXd S_beta_pri, double l_s, Eigen::VectorXd l_t, double d_s, Eigen::VectorXd d_t, double g_s, Eigen::VectorXd g_t, int s, int nsamp, int verbose, Eigen::VectorXd beta_init, double sigma2_init, Eigen::VectorXd tau2_init);
static SEXP _BayesLN_MCMC_alg_try(SEXP ySEXP, SEXP XSEXP, SEXP Z_listSEXP, SEXP K_gamma_listSEXP, SEXP S_beta_priSEXP, SEXP l_sSEXP, SEXP l_tSEXP, SEXP d_sSEXP, SEXP d_tSEXP, SEXP g_sSEXP, SEXP g_tSEXP, SEXP sSEXP, SEXP nsampSEXP, SEXP verboseSEXP, SEXP beta_initSEXP, SEXP sigma2_initSEXP, SEXP tau2_initSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const Eigen::VectorXd >::type y(ySEXP);
    Rcpp::traits::input_parameter< const Eigen::MatrixXd >::type X(XSEXP);
    Rcpp::traits::input_parameter< const List >::type Z_list(Z_listSEXP);
    Rcpp::traits::input_parameter< const List >::type K_gamma_list(K_gamma_listSEXP);
    Rcpp::traits::input_parameter< const Eigen::MatrixXd >::type S_beta_pri(S_beta_priSEXP);
    Rcpp::traits::input_parameter< double >::type l_s(l_sSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type l_t(l_tSEXP);
    Rcpp::traits::input_parameter< double >::type d_s(d_sSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type d_t(d_tSEXP);
    Rcpp::traits::input_parameter< double >::type g_s(g_sSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type g_t(g_tSEXP);
    Rcpp::traits::input_parameter< int >::type s(sSEXP);
    Rcpp::traits::input_parameter< int >::type nsamp(nsampSEXP);
    Rcpp::traits::input_parameter< int >::type verbose(verboseSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type beta_init(beta_initSEXP);
    Rcpp::traits::input_parameter< double >::type sigma2_init(sigma2_initSEXP);
    Rcpp::traits::input_parameter< Eigen::VectorXd >::type tau2_init(tau2_initSEXP);
    rcpp_result_gen = Rcpp::wrap(MCMC_alg(y, X, Z_list, K_gamma_list, S_beta_pri, l_s, l_t, d_s, d_t, g_s, g_t, s, nsamp, verbose, beta_init, sigma2_init, tau2_init));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesLN_MCMC_alg(SEXP ySEXP, SEXP XSEXP, SEXP Z_listSEXP, SEXP K_gamma_listSEXP, SEXP S_beta_priSEXP, SEXP l_sSEXP, SEXP l_tSEXP, SEXP d_sSEXP, SEXP d_tSEXP, SEXP g_sSEXP, SEXP g_tSEXP, SEXP sSEXP, SEXP nsampSEXP, SEXP verboseSEXP, SEXP beta_initSEXP, SEXP sigma2_initSEXP, SEXP tau2_initSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesLN_MCMC_alg_try(ySEXP, XSEXP, Z_listSEXP, K_gamma_listSEXP, S_beta_priSEXP, l_sSEXP, l_tSEXP, d_sSEXP, d_tSEXP, g_sSEXP, g_tSEXP, sSEXP, nsampSEXP, verboseSEXP, beta_initSEXP, sigma2_initSEXP, tau2_initSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// post_pred
Eigen::MatrixXd post_pred(List output, Eigen::MatrixXd Xrep, List Zrep_list, int s, int nsamp);
static SEXP _BayesLN_post_pred_try(SEXP outputSEXP, SEXP XrepSEXP, SEXP Zrep_listSEXP, SEXP sSEXP, SEXP nsampSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< List >::type output(outputSEXP);
    Rcpp::traits::input_parameter< Eigen::MatrixXd >::type Xrep(XrepSEXP);
    Rcpp::traits::input_parameter< List >::type Zrep_list(Zrep_listSEXP);
    Rcpp::traits::input_parameter< int >::type s(sSEXP);
    Rcpp::traits::input_parameter< int >::type nsamp(nsampSEXP);
    rcpp_result_gen = Rcpp::wrap(post_pred(output, Xrep, Zrep_list, s, nsamp));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _BayesLN_post_pred(SEXP outputSEXP, SEXP XrepSEXP, SEXP Zrep_listSEXP, SEXP sSEXP, SEXP nsampSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_BayesLN_post_pred_try(outputSEXP, XrepSEXP, Zrep_listSEXP, sSEXP, nsampSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _BayesLN_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("void(*rmn_mu_S2)(Eigen::VectorXd&,const int,const Eigen::VectorXd,const Eigen::MatrixXd)");
        signatures.insert("Rcpp::List(*MCMC_alg)(const Eigen::VectorXd,const Eigen::MatrixXd,const List,const List,const Eigen::MatrixXd,double,Eigen::VectorXd,double,Eigen::VectorXd,double,Eigen::VectorXd,int,int,int,Eigen::VectorXd,double,Eigen::VectorXd)");
        signatures.insert("Eigen::MatrixXd(*post_pred)(List,Eigen::MatrixXd,List,int,int)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _BayesLN_RcppExport_registerCCallable() { 
    R_RegisterCCallable("BayesLN", "_BayesLN_rmn_mu_S2", (DL_FUNC)_BayesLN_rmn_mu_S2_try);
    R_RegisterCCallable("BayesLN", "_BayesLN_MCMC_alg", (DL_FUNC)_BayesLN_MCMC_alg_try);
    R_RegisterCCallable("BayesLN", "_BayesLN_post_pred", (DL_FUNC)_BayesLN_post_pred_try);
    R_RegisterCCallable("BayesLN", "_BayesLN_RcppExport_validate", (DL_FUNC)_BayesLN_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_BayesLN_rmn_mu_S2", (DL_FUNC) &_BayesLN_rmn_mu_S2, 4},
    {"_BayesLN_MCMC_alg", (DL_FUNC) &_BayesLN_MCMC_alg, 17},
    {"_BayesLN_post_pred", (DL_FUNC) &_BayesLN_post_pred, 5},
    {"_BayesLN_RcppExport_registerCCallable", (DL_FUNC) &_BayesLN_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

RcppExport void R_init_BayesLN(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
}
